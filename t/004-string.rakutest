use F2::JSON :import;
use Test;

plan 16;

my @ws = " ", "\x[A]", "\x[D]", "\x[9]";
@ws = @ws.combinations(1..2).map(*.permutationsÂ».join).flat;

is-deeply JSON.parse('""'), "", 'Â«""Â» empty string';
dies-ok { JSON.parse("''") }, "Â«''Â» string require \"";
is-deeply JSON.parse("\"\x[1d11e]\""), "ğ„", 'Â«"ğ„"Â»';
is-deeply JSON.parse("\"\\uD834\\uDD1E\""), "ğ„", 'Â«"\\uD834\\uDD1E"Â»';
is-deeply JSON.parse("\"\\ud834\\udd1e\""), "ğ„", 'Â«"\\ud834\\udd1e"Â»';
is-deeply JSON.parse('"\\""'), '"', 'Â«"\\""Â» quote string';
is-deeply JSON.parse('"\\\\"'), '\\', 'Â«"\\\\"Â» backslash string';
is-deeply JSON.parse('"\\/"'), '/', 'Â«"\\/"Â» slash string';
is-deeply JSON.parse('"\\b"'), "\x[8]", 'Â«"\\b"Â» backspace string';
is-deeply JSON.parse('"\\f"'), "\x[C]", 'Â«"\\f"Â» form feed string';
is-deeply JSON.parse('"\\n"'), "\x[A]", 'Â«"\\n"Â» line feed string';
is-deeply JSON.parse('"\\r"'), "\x[D]", 'Â«"\\r"Â» carriage return string';
is-deeply JSON.parse('"\\t"'), "\x[9]", 'Â«"\\t"Â» tab string';
subtest "Space before/after", {
    my @string-values = @ws X~ '"abc"' X~ @ws;
    plan +@string-values;
    is-deeply JSON.parse($_), 'abc', $_.raku for @string-values;
}

# see https://github.com/moritz/json/issues/25
is-deeply JSON.parse("\"\c[ZERO WIDTH JOINER]\""), "\c[ZERO WIDTH JOINER]", 'ZERO WIDTH JOINER';
is-deeply JSON.parse("\"\x[85]\""), "\x[85]", "\x85";

done-testing;
